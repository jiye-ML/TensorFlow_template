## 这部分很重要

* 在程序员的日常工作之中，绝大多数时间都是在阅读代码，而不是在写代码。但是，阅读代码往往是一件很枯燥的事情，
尤其当遇到了一个不漂亮的设计，反抗的心理往往更加强烈。事实上，变换一下习惯、思路和方法，代码阅读其实是一个很享受的过程。
阅读代码的模式，实践和习惯，集大成者莫过于希腊作者 Diomidis Spinellis 的经典之作：
 Code Reading, The Open Source Perspective。本文从另外一个视角出发，谈谈我阅读代码的一些习惯，期待找到更多知音的共鸣。
--摘自《tensorflow 内核剖析》


### A.2 力行而后知之真

* 阅读代码一种常见的反模式就是通过 Debug 的方式来阅读代码。作者不推荐这种代码阅读的方式，
    1. 因为运行时线程间的切换很容易导致方向的迷失;
    2. 了解代码调用栈对于理解系统行为并非见得有效，因为其包含太多实现细节，不易发现问题的本质。

* 但在阅读代码之前，有几件事情是必须做的。其一，手动地构建一次工程，并运行测试用例；其二，亲自动手写几个 Demo 感受一下。



### A.3 发现领域模型

* 阅读代码，不是为了了解每个类，每个函数干什么，而是为了挖掘更本质，更不易变化的知识。
事实上，发现领域模型是阅读代码最重要的一个目标，因为领域模型是系统的灵魂所在。
通过代码阅读，找到系统本质的知识，并通过自己的模式表达出来，才能真正地抓住系统的脉络，否则一切都是空谈。



### A.4 挖掘系统架构

* 阅读代码犹如在大海中航行，系统架构图就是航海图。阅读代码不能没有整体的系统概念，否则收效不佳，阅读质量大大折扣。
必须拥有系统思维，并明确目标，才不至于迷失方向。
* 首要的任务，就是找到系统的边界，并能够以抽象的思维思考外部系统的行为特征。
其次，理清系统中各组件之间的交互，关联关系，及其职责，对于理解整个系统的行为极为重要。



### A.5 细节是魔鬼

* 纠结于细节，将导致阅读代码的效率和质量大大折扣。例如，日志打印，解决某个Bug 的补丁实现，某版本分支的兼容方案，某些变态需求的锤子代码实现等等。
* 阅读代码的一个常见的反模式就是「给代码做批注」。这是一个高耗低效，投入产出比极低的实践。
一般地，越是优雅的系统，注释越少；越是复杂的系统，再多的注释也是于事无补。
* 我有一个代码阅读的习惯，为代码阅读建立一个单独的 code-reading 分支，一边阅读代码，一边删除这些无关的代码。
* 删除这些噪声后，你会发现系统根本没有想象之中那么复杂。
现实中，系统的复杂性，往往都是不成熟的设计和实现导致的额外复杂度。
随着对系统的深入理解，很多细节都会自然地浮出水面，所有神秘的面纱都将被揭开而公示天下。


### A.6 适可而止

* 阅读代码的一个常见的反模式就是「一根筋走到底，不到黄河绝不死心」。程序员都拥有一颗好奇心，总是对不清楚的事情感兴趣。
例如，消息是怎么发送出去的？任务调度工作原理是什么？数据存储怎么做到的？
虽然这种勇气值得赞扬，但在代码阅读时绝对不值得鼓励。
* 另外一个常见的反模式就是「追踪函数调用栈」。这是一个极度枯燥的过程，常常导致思维的僵化；因为你永远活在作者的阴影下，完全没有自我。
* 我个人阅读代码的时候，函数调用栈深度绝不超过 3，然后使用抽象的思维方式思考底层的调用。
因为我发现，随着年龄的增长，曾今值得骄傲的记忆力，现在逐渐地变成自己的短板。
当我尝试追踪过深的调用栈之后，之前的阅读信息完全地消失记忆了。
也就是说，我更习惯于「广度遍历」，而不习惯于「深度遍历」的阅读方式。这样，我才能找到系统隐晦存在的「分层概念」，并理顺系统的层次结构。


### A.7 发现她的美

* 三人行，必有我师焉。在代码阅读代码时，当发现好的设计，包括实现模式，习惯用法等，千万不要错过；
否则过上一段时间，这次代码阅读对你来说就没有什么价值了。
* 当我发现一个好的设计时，我会尝试使用类图，状态机，序列图等方式来表达设计；
如果发现潜在的不足，将自己的想法补充进去，将更加完美。
例如，当我阅读 Hamcrest 时，尝试画画类图，并体会它们之间关系，感受一下设计的美感，也是受益颇多的。


### A.8 尝试重构

* 因为这是一次代码阅读的过程，不会因为重构带来潜在风险的问题。在一些复杂的逻辑，通过重构的等价变换可以将其变得更加明晰，直观。
* 对于一个巨函数，我常常会提取出一个抽象的代码层次，以便发现它潜在的本质逻辑。
例如，这是一个使用 Scala 实现的 ArrayBuﬀer，当需要在尾部添加一个元素时，既有的设计是这样子的。


### A.9 形式化

* 当阅读代码时，有部分人习惯画程序的「流程图」。相反，我几乎从来不会画「流程图」，因为流程图反映了太多的实现细节，而不能深刻地反映算法的本质。
我更倾向于使用「形式化」的方式来描述问题。它拥有数学的美感，简洁的表达方式，及其高度抽象的思维，对挖掘问题本质极其关键。
例如，对于 FizzBuzzWhizz 的问题，相对于冗长的文字描述，或流程图，形式化的方式将更加简单，并富有表达力。
以 3, 5, 7 为输入，形式化后描述后，可清晰地挖掘出问题的本质所在；
```
r1: times(3) => Fizz ||
times(5) => Buzz ||
times(7) => Whizz

r2: times(3) && times(5) && times(7) => FizzBuzzWhizz ||
times(3) && times(5) => FizzBuzz ||
times(3) && times(7) => FizzWhizz ||
times(5) && times(7) => BuzzWhizz

r3: contains(3) => Fizz
rd: others => string of others
spec: r3 || r2 || r1 || rd
```


### A.10 实例化

* 实例化是认识问题的一种重要方法，当逻辑非常复杂时，一个简单例子往往使自己豁然开朗。
在理想的情况下，实例化可以做成自动化的测试用例，并以此描述系统的行为。
如果存在某个算法和实现都相当复杂时，也可以通过实例化探究算法的工作原理，这对于理解问题本身大有益处。
以 Spark 中划分 DAG 算法为例。以 G 为起始节点，从后往前按照 RDD 的依赖关系，依次识别出各个 Stage 的边界。
```
Stage 3 的划分
    1. G 与 B 之间是窄依赖，规约为同一 Stage(3)；
    2. B 与 A 之间是宽依赖， A 为新的起始 RDD，递归调用此过程；
    3. G 与 F 之间是宽依赖， F 为新的起始 RDD，递归调用此过程。

• Stage 1 的划分
    1. A 没有父亲 RDD， Stage(1) 划分结束。特殊地 Stage(1) 仅包含 RDD A。

• Stage 2 的划分
    1. 因 RDD 之间的关系都为窄依赖，规约为同一个 Stage(2)；
    2. 直至 RDD C, E，因没有父亲 RDD， Stage(2) 划分结束。
```




## 持续学习


### 选择

* 耳到，择其善者而从之，择不善者而改之。有人习惯于巨函数，大逻辑，问究为何如此，
美其名曰：都是为了效 (hai) 率 (zi)；而我更偏爱具有层次感的代码风格，短小精干，意图明确。
* 他人的经验固然重要，但需要我们自己选择性地接收，而不是一味的听取。不要为大师所迷，大师有时也会犯错。
关键在于自我思考，善于辨别。尤其在这个浮躁的世间里，能在地上跑的都喊自己是“大师”。


### 抽象

* 眼到，扫除外物，直觅本来也。一眼便能看到的都是假象，看不到，摸不着的往往才是本质。
有人习惯平铺直叙的的逻辑，任其重复；而我更加偏爱抽象，并将揭示本质过程当成一种享受。
* 抽象，固然存在复杂度。但这样的复杂度是存在上下文的，如果大家具有类似的经验，抽象自然就变成了模式。
那是一种美，一种沟通的媒介。
* 如果对方缺乏上下文，抽象自然是困难的。所谓简单，是问题本质的揭示，并为此付出最小的代价；
而不是平铺直叙，简单是那些门外汉永远也感受不到的美感。
过而不及，盲目抽象，必然增加不必要的复杂度。犹如大规模的预先设计，畅谈客户的各种需求，畅谈软件设计中各种变化，盲目抽象。


### 分享

* 口到，传道，授业，解惑也。分享是一种生活的信念，明白了分享的同时，自然明白了存在的意义。
我喜欢分享自己的知识，并将其当成一种学习动力，督促自己透彻理解问题的本质。
* 因为能够分享，所以知识自然变成了自己的东西。每日的 Code Review，我常常鼓励团队成员积极分享，
一则为了促就无差异的团队，二则协助分享者透彻问题的本质。
* 要让别人信服你的观点，关键是要给别人带来信服的理由。分享的同时，能够帮助锻炼自己的表达能力，这需要长时间的刻意练习。


### 领悟

* 心到，学而思之，思则得之，不思则不得也。只有通过自己独立思考，归纳总结的知识，才是真正属于自己的。
* 我偏爱使用图表来总结知识，一方面图的表达力远远大于文字；另外，通过画图也逼迫自己能够透彻问题的本质。



### 消除重复

* 代码需要消除重复，工作的习惯也要消除重复。不要拘于固有的工作状态，重复的工作状态往往使人陷入舒服的假象，陷入三年效应的危机。

### 提炼知识

* 首先我们学习的不是信息，而是知识。知识是有价值的，而信息则没有价值。只有通过自己的筛选，提炼，总结才可能将信息转变为知识。


###  成为习惯

* 知识是容易忘记的，只有将知识付诸于行动，并将其融汇到自己的工作状态中去，才能永久性地成为自己的财产。
例如，快捷键的使用，不要刻意地去记忆，而是变成自己的一种工作习惯；不要去重复地劳动，使用 Shell 提供自动化程度，
让 Shell 成为工作效率提升的利器，并将成为一种工作习惯。


### 更新知识

* 我们需要常常更新既有的知识体系，尤其我们处在一个知识大爆炸的时代。我痛恨那些信守教条的信徒，
举个简单的例子，陈旧的代码规范常常要求 if (NULL != p) 这样的 YODA Notation 习惯用法。
但是这样的表达编译器是高兴了，但对程序员是非常不友好的。
“if you are at least 18 years old” 明显比“if 18 years is less than or equal to your age”
更加符合英语表达习惯。
有人驳论此这个习惯用法，但是现代编译器对此类误用通常报告警告；而且保持 TDD开发节奏，小步前进，此类低级错误很难逃出测试的法网。


### 重构自我

* 学，然后知不足；教，然后知困。不要停留在原点，应该时刻重构自己的知识体系。
* 在刚入门 OO 设计的时候，我无处不用设计模式；因为我看到的所有书籍，都是在讲设计模式如何如何地好。
直至后来看到了演进式设计，简单设计和过度设计的一些观点后，让我重新回归到理性。





























