'''学习 tensor先关的东西https://www.tensorflow.org/programmers_guide/tensorshttps://www.tensorflow.org/api_docs/python/tf/Tensor'''import tensorflow as tf'''TensorFlow, 是一个框架，定义和运行计算在tensor上 A tensor 是潜在可以构建更高维度的一个向量或者矩阵 tensorflow将tensor表示为基础数据类型的n维数组A tf.Tensor 包含如下属性:    a data type (float32, int32, or string, for example)    a shape    tensor中的每个元素都有同样的数据类型，并且数据类型是已知的tf.Variabletf.constanttf.placeholdertf.SparseTensor'''# 1. Rank 0# mammal = tf.Variable("Elephant", tf.string)# ignition = tf.Variable(451, tf.int16)# floating = tf.Variable(3.14159265359, tf.float64)# its_complicated = tf.Variable(12.3 - 4.85j, tf.complex64)# 2. 获取 tensor对象的 rank# 使用 tf.rank 方法获得 tensor的rank# r = tf.rank(my_image)# 3. shape# shape是tensor每个维度的元素个数，shape利用op中注册的shape推断函数来计算shape.查看tf.TensorShape 获得shape表示的更多信息# 提供的shape信息通常在不运行图的时候提供shape信息.这可以用来调试和提供更多的早期错误信息# c = tf.constant([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])# print(c.shape)    # ==> TensorShape([Dimension(2), Dimension(3)])# d = tf.constant([[1.0, 0.0], [0.0, 1.0], [1.0, 0.0], [0.0, 1.0]])# print(d.shape)    # ==> TensorShape([Dimension(4), Dimension(2)])# 报错：c和d不兼容# e = tf.matmul(c, d)# f = tf.matmul(c, d, transpose_a=True, transpose_b=True)# print(f.shape)    # ==> TensorShape([Dimension(3), Dimension(4)])# 在一些情况下，给出的shape没有维度信息，如果调用者需要额外的维度信息，可以使用 Tensor.set_shape()# 3.1 set_shape# _, image_data = tf.TFRecordReader(...).read(...)# image = tf.image.decode_png(image_data, channels=3)# height和width信息是依赖于数据的，所以没有执行计算前无法获得# print(image.shape)    ==> TensorShape([Dimension(None), Dimension(None), Dimension(3)])# # 我们了解到这个数据集上每张图片是28 x 28 pixels.# image.set_shape([28, 28, 3])# print(image.shape)     ==> TensorShape([Dimension(28), Dimension(28), Dimension(3)])# 4. Changing the shape of a tf.Tensor# tensor中元素的数量是每个维度元素数量的乘积.# 很多不同shape的tensor有着相同的元素, 在保持元素固定的情况下转换tensor的shape是方便的,# This can be done with tf.reshape# rank_three_tensor = tf.ones([3, 4, 5])# matrix = tf.reshape(rank_three_tensor, [6, 10])# matrixB = tf.reshape(matrix, [3, -1])# matrixAlt = tf.reshape(matrixB, [4, 3, -1])# reshape前后总的元素数量必须不变# yet_another = tf.reshape(matrixAlt, [13, 2, -1])  # ERROR!# 5. Data types# float_tensor = tf.cast(tf.constant([1, 2, 3]), dtype=tf.float32)# 6. Evaluating Tensors# constant = tf.constant([1, 2, 3])# tensor = constant * constant# tensor.eval(session=tf.get_default_session())# 有时eval一个tensor没有上下文信息是不行的，因为你可鞥依赖于动态的信息，# 例如, 依赖placeholders在没有给placeholder提供值前，不能eval# p = tf.placeholder(tf.float32)# t = p + 1.0# t.eval()  # This will fail, since the placeholder did not get a value.# t.eval(feed_dict={p:2.0})# 7. __abs__# x = tf.constant([[-2.25 + 4.75j], [-3.25 + 5.75j]])# tf.abs(x)  # [5.25594902, 6.60492229]# 8. __bool__# Dummy method to prevent a tensor from being used as a Python bool.# This overload raises a TypeError when the user inadvertently treats a Tensor as a boolean (e.g. in an if statement). For example:# if tf.constant(True):  # Will raise.# if tf.constant(5) < tf.constant(7):  # Will raise.# 9. __getitem__# strip leading and trailing 2 elements# foo = tf.constant([1,2,3,4,5,6])# print(foo[2:-2].eval())  # => [3,4]## 行：每两个元素取一个， 列：每个元素取一个，元素翻转# foo = tf.constant([[1,2,3], [4,5,6], [7,8,9]])# print(foo[::2,::-1].eval())  # => [[3,2,1], [9,8,7]]# Use scalar tensors as indices on both dimensions# print(foo[tf.constant(0), tf.constant(2)].eval())  # => 3# 增加一个维度# foo = tf.constant([[1,2,3], [4,5,6], [7,8,9]])# print(foo[tf.newaxis, :, :].eval()) # => [[[1,2,3], [4,5,6], [7,8,9]]]# print(foo[:, tf.newaxis, :].eval()) # => [[[1,2,3]], [[4,5,6]], [[7,8,9]]]# print(foo[:, :, tf.newaxis].eval()) # => [[[1],[2],[3]], [[4],[5],[6]],# [[7],[8],[9]]]# 三种相同的操作# foo = tf.constant([[1,2,3], [4,5,6], [7,8,9]])# print(foo[tf.newaxis, :, :].eval())  # => [[[1,2,3], [4,5,6], [7,8,9]]]# print(foo[tf.newaxis, ...].eval())  # => [[[1,2,3], [4,5,6], [7,8,9]]]# print(foo[tf.newaxis].eval())  # => [[[1,2,3], [4,5,6], [7,8,9]]]