'''数据操作指南    https://segmentfault.com/a/1190000008793389    Tensor Transformation：    拼接， 抽取， 类型转化， 形状转化SparseTensor字符串操作：    拆分， 拼接， 自定义op'''import tensorflow as tfimport numpy as npimport json''' Tensor Transformation：    拼接， 抽取， 类型转化， 形状转化 '''# 测试拼接的两种方法# tf.concat(values, axis, name='concat')：按照指定的已经存在的轴进行拼接# tf.stack(values, axis=0, name='stack')：按照指定的新建的轴进行拼接def test_concat_and_stack():    '''     t1 = [[1, 2, 3], [4, 5, 6]]    t2 = [[7, 8, 9], [10, 11, 12]]    tf.concat([t1, t2], 0) == > [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]    tf.concat([t1, t2], 1) == > [[1, 2, 3, 7, 8, 9], [4, 5, 6, 10, 11, 12]]    tf.stack([t1, t2], 0) == > [[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]    tf.stack([t1, t2], 1) == > [[[1, 2, 3], [7, 8, 9]], [[4, 5, 6], [10, 11, 12]]]    tf.stack([t1, t2], 2) == > [[[1, 7], [2, 8], [3, 9]], [[4, 10], [5, 11], [6, 12]]]    '''    # 直观解释    t1 = [[1, 2, 3], [4, 5, 6]]    t2 = [[7, 8, 9], [10, 11, 12]]    tf.concat([t1, t2], 0)  # [2,3] + [2,3] ==> [4, 3]    tf.concat([t1, t2], 1)  # [2,3] + [2,3] ==> [2, 6]    tf.stack([t1, t2], 0)  # [2,3] + [2,3] ==> [2*,2,3]    tf.stack([t1, t2], 1)  # [2,3] + [2,3] ==> [2,2*,3]    tf.stack([t1, t2], 2)  # [2,3] + [2,3] ==> [2,3,2*]# 抽取# tf.slice(input_, begin, size, name=None)：按照指定的下标范围抽取连续区域的子集# tf.gather(params, indices, validate_indices=None, name=None)：按照指定的下标集合从axis=0中抽取子集，适合抽取不连续区域的子集def test_slice_and_gather():    '''    input = [[[1, 1, 1], [2, 2, 2]],         [[3, 3, 3], [4, 4, 4]],         [[5, 5, 5], [6, 6, 6]]]    tf.slice(input, [1, 0, 0], [1, 1, 3]) ==> [[[3, 3, 3]]]    tf.slice(input, [1, 0, 0], [1, 2, 3]) ==> [[[3, 3, 3],                                                [4, 4, 4]]]    tf.slice(input, [1, 0, 0], [2, 1, 3]) ==> [[[3, 3, 3]],                                               [[5, 5, 5]]]                                                   tf.gather(input, [0, 2]) ==> [[[1, 1, 1], [2, 2, 2]],                                  [[5, 5, 5], [6, 6, 6]]]        '''    pass# 类型转化# tf.string_to_number(string_tensor, out_type=None, name=None): 将字符串转化为tf.float32（默认）和tf.int32# tf.to_double(x, name='ToDouble')：转化为tf.float64# tf.to_float(x, name='ToFloat')：转化为tf.float32# tf.to_int32(x, name='ToInt32')：转化为tf.int32# tf.to_int64(x, name='ToInt64')：转化为tf.int64# tf.cast(x, dtype, name=None)：转化为dtype指定的类型# 形状转化# tf.reshape(tensor, shape, name=None)：转化为新shape，若有一个维度设置为-1，会自动推导'''SparseTensor'''# TensorFlow使用三个dense tensor来表达一个sparse tensor：indices、values、dense_shapes'''字符串操作：    拆分， 拼接， 自定义op'''# 拆分def split():    '''    source是一维数组，用于将一组字符串按照delimiter拆分为多个元素，返回值为一个SparseTensor。    假如有两个字符串，source[0]是“hello world”，source[1]是“a b c”，那么输出结果如下：        st.indices： [0, 0; 0, 1; 1, 0; 1, 1; 1, 2]    st.values： ['hello', 'world', 'a', 'b', 'c']    st.dense_shape：[2, 3]    '''# 拼接# tf.string_join(["hello", "world"], separator=" ") ==> "hello world"# 自定义op#通过tf.py_func(func, inp, Tout, stateful=True, name=None)可以将任意的python函数func转变为TensorFlow op。# func接收的输入必须是numpy array，可以接受多个输入参数；输出也是numpy array，也可以有多个输出。inp传入输入值，Tout指定输出的基本数据类型。# 先看一个解析json的例子，输入是一个json array，输出是一个特征矩阵def test_op_json():    json_str_1 = {"name": "shuiping.chen",                  "score": 95,                  "department": "industrial engineering",                  "rank": 2                  }    json_str_2 = {"name": "zhuibing.dan",                  "score": 87,                  "department": "production engineering",                  "rank": 4                  }    input_array = np.array([json_str_1, json_str_2])    def parse_json(json_str_array):        fea_dict_array = [json.loads(item) for item in json_str_array]        ret_feature = []        for fea_dict in fea_dict_array:            feature = [fea_dict["score"], fea_dict["rank"]]            ret_feature.append(feature)        return np.array(ret_feature, dtype=np.float32)    parse_json_op = tf.py_func(parse_json, [input_array], tf.float32)    sess = tf.Session()    print(sess.run(parse_json_op))    pass# 再看一个多输入多输出的例子，输入两个numpy array，输出三个array，分别是和、差、乘积def test_op():    array1 = np.array([[1, 2], [3, 4]], dtype=np.float32)    array2 = np.array([[5, 6], [7, 8]], dtype=np.float32)    def add_minus_dot(array1, array2):        return array1 + array2, array1 - array2, np.dot(array1, array2)    add_minus_dot_op = tf.py_func(add_minus_dot, [array1, array2], [tf.float32, tf.float32, tf.float32])    with tf.Session() as sess:        add_minus_dot = sess.run(add_minus_dot_op)        print()if __name__ == '__main__':    test_op()    pass